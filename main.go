package main

import (
	"blanktiger/hm/lib"
	"encoding/json"
	"flag"
	"log/slog"
	"os"
)

var homeDir = os.Getenv("HOME")

func main() {
	copy := flag.Bool("copy", false, "copies the config files instead of symlinking them")
	debug := flag.Bool("dbg", false, "set logging level to debug")

	install := flag.Bool("install", false, "whether to install packages using INSTALL instructions found in config folders")
	onlyInstall := flag.Bool("only-install", false, "doesnt copy configs over, only installs the packages that would be copied over based on their INSTALL instructions, --install can be omitted if this option is used")

	uninstall := flag.Bool("uninstall", false, "whether to uninstall packages using INSTALL instructions found in config folders")
	onlyUninstall := flag.Bool("only-uninstall", false, "doesnt copy configs over, only uninstalls the packages for configs that would be removed based on their instructions, --uninstall can be omitted if this option is used")

	pkgs := flag.String("pkgs", "", "installs/uninstalls only the packages specified by this argument, empty means work on all active, non-hidden configs")

	sourcedir := flag.String("sourcedir", homeDir+"/.config/homecfg", "source of configuration files, without the trailing /")
	// TODO: UNCOMMENT AFTER FINISHING TESTING
	// targetDirDefault := homeDir + "/.config"
	targetDirDefault := homeDir + "/.configbkp"
	targetdir := flag.String("targetdir", targetDirDefault, "target for symlinks for debugging, without the trailing /")
	flag.Parse()

	if *debug {
		slog.SetLogLoggerLevel(slog.LevelDebug)
		lib.Level = slog.LevelDebug
	}
	cli_args := "cli args"
	lib.Logger.Debug(cli_args, "copy", *copy)
	lib.Logger.Debug(cli_args, "dbg", *debug)
	lib.Logger.Debug(cli_args, "install", *install)
	lib.Logger.Debug(cli_args, "only-install", *onlyInstall)
	lib.Logger.Debug(cli_args, "uninstall", *uninstall)
	lib.Logger.Debug(cli_args, "only-uninstall", *onlyUninstall)
	lib.Logger.Debug(cli_args, "pkgs", *pkgs)
	lib.Logger.Debug(cli_args, "sourcedir", *sourcedir)
	lib.Logger.Debug(cli_args, "targetdir", *targetdir)

	dirPath := *sourcedir + "/config"
	entries, err := os.ReadDir(dirPath)
	if err != nil {
		lib.Logger.Error("couldn't read dir", "err", err)
		return
	}

	lockfilePath := *targetdir + "/hmlock.json"
	lockfile, err := lib.ReadOrCreateLockfile(lockfilePath)
	if err != nil {
		lib.Logger.Error("something went wrong while parsing the lockfile, you might need to remove it manually (possibly was generated by previous version of `hm`", "err", err)
		return
	}
	lockfileBefore := *lockfile
	defer func() {
		err := lockfile.Save(lockfilePath)
		if err != nil {
			lib.Logger.Error("something went wrong while trying to save the lockfile", "err", err)
			return
		}
	}()

	// TODO: think if this is correct, for now just reset
	*lockfile = lib.DefaultLockfile

	if *copy {
		lib.Logger.Debug("setting mode to cpy")
		lockfile.Mode = lib.Cpy
	} else {
		lib.Logger.Debug("setting mode to dev")
		lockfile.Mode = lib.Dev
	}

	for _, e := range entries {
		if e.Type() != os.ModeDir {
			continue
		}

		name := e.Name()
		if name == ".git" {
			continue
		}

		from := dirPath + "/" + name
		to := *targetdir + "/" + name

		if name[0] == '.' {
			lib.Logger.Info("configs", "skipping", name)
			// skipping the dot
			nameIfNotSkipped := name[1:]
			fromIfNotSkipped := dirPath + "/" + nameIfNotSkipped
			toIfNotSkipped := *targetdir + "/" + nameIfNotSkipped
			config := lib.NewConfig(nameIfNotSkipped, fromIfNotSkipped, toIfNotSkipped, nil)
			lockfile.AppendSkippedConfig(config)
			continue
		}

		requirements, err := lib.ParseRequirements(from)
		if err != nil {
			lib.Logger.Error("something went wrong while trying to parse requirements", "err", err)
			return
		}

		config := lib.NewConfig(name, from, to, requirements)
		lockfile.AddConfig(config)
	}

	if !*onlyUninstall {
		for idx, cfg := range lockfile.Configs {
			if *install || *onlyInstall {
				if *pkgs != "" {
				}
			}

			if *onlyInstall {
				continue
			}

			if *copy {
				lib.Logger.Info("copying", "from", cfg.From, "to", cfg.To)
				err := lib.Copy(cfg.From, cfg.To)
				if err != nil {
					lib.Logger.Error("couldn't copy", "err", err)
					return
				}
			} else {
				lib.Logger.Info("symlinking", "from", cfg.From, "to", cfg.To)
				err := lib.Symlink(cfg.From, cfg.To)
				if err != nil {
					lib.Logger.Error("couldn't symlink", "err", err)
					return
				}
			}
		}
	}

	if *uninstall || *onlyUninstall {
		for idx, cfg := range lockfile.SkippedConfigs {
			if *pkgs != "" {
			}
		}
	}

	lockDiff := lockfileBefore.Diff(lockfile)
	{
		lockDiffJson, err := json.Marshal(&lockDiff)
		if err != nil {
			lib.Logger.Error("couldnt marshal lockdiff", "err", err)
			return
		}
		lib.Logger.Info("lockfile diff", "diff", lockDiff, "as json", string(lockDiffJson))

		lib.Logger.Info("removing configs that are no longer in the source")
		err = lib.RemoveConfigsFromTarget(lockDiff.RemovedConfigs)
		if err != nil {
			lib.Logger.Error("something went wrong while removing a config", "mode", lockfile.Mode)
			return
		}

		lib.Logger.Info("removing configs that are skipped")
		err = lib.RemoveConfigsFromTarget(lockDiff.NewlySkippedConfigs)
		if err != nil {
			lib.Logger.Error("something went wrong while removing a config", "mode", lockfile.Mode)
			return
		}
	}

}
