package main

import (
	"blanktiger/hm/instructions"
	"blanktiger/hm/lib"
	"flag"
	"log/slog"
	"os"
	"slices"
	"strings"
)

var homeDir = os.Getenv("HOME")

func main() {
	copyMode := flag.Bool("copy", false, "copies the config files instead of symlinking them")
	debug := flag.Bool("dbg", false, "set logging level to debug")

	// TODO: think if this is something that should be done at all times, or not
	// saveLockDiff := flag.Bool("save-diff", false, "wheter to save lockfile diff from before and after to a file regardless of the --debug flag")

	install := flag.Bool("install", false, "whether to install packages using INSTALL instructions found in config folders")
	onlyInstall := flag.Bool("only-install", false, "doesnt copy configs over, only installs the packages that would be copied over based on their INSTALL instructions, --install can be omitted if this option is used")

	uninstall := flag.Bool("uninstall", false, "whether to uninstall packages using INSTALL instructions found in config folders")
	onlyUninstall := flag.Bool("only-uninstall", false, "doesnt copy configs over, only uninstalls the packages for configs that would be removed based on their instructions, --uninstall can be omitted if this option is used")

	upgrade := flag.Bool("upgrade", false, "whether to upgrade already installed packages, for now simply reruns the original install instruction")

	pkgsTxt := flag.String("pkgs", "", "installs/uninstalls only the packages specified by this argument, empty means work on all active, non-hidden configs, example: --pkgs fish,ghostty")

	sourcedir := flag.String("sourcedir", homeDir+"/.config/homecfg", "source of configuration files, without the trailing /")
	// TODO: UNCOMMENT AFTER FINISHING TESTING
	// targetDirDefault := homeDir + "/.config"
	targetDirDefault := homeDir + "/.configbkp"
	targetdir := flag.String("targetdir", targetDirDefault, "target for symlinks for debugging, without the trailing /")
	flag.Parse()

	defaultIndent := "    "
	var level = slog.LevelInfo
	var opts = slog.HandlerOptions{Level: &level}
	logger := slog.New(slog.NewTextHandler(os.Stdout, &opts))
	lib.Logger = logger
	instructions.Logger = logger
	// TODO: make this better, if this gets commented out, then we won't ever
	// find the system package manager
	instructions.FindSystemPkgManager()
	if *debug {
		slog.SetLogLoggerLevel(slog.LevelDebug)
		level = slog.LevelDebug
	}

	// show flag information
	{
		cli_args := "cli args"
		lib.Logger.Debug(cli_args, "copy", *copyMode)
		lib.Logger.Debug(cli_args, "dbg", *debug)
		lib.Logger.Debug(cli_args, "install", *install)
		lib.Logger.Debug(cli_args, "only-install", *onlyInstall)
		lib.Logger.Debug(cli_args, "uninstall", *uninstall)
		lib.Logger.Debug(cli_args, "only-uninstall", *onlyUninstall)
		lib.Logger.Debug(cli_args, "upgrade", *upgrade)
		lib.Logger.Debug(cli_args, "pkgs", *pkgsTxt)
		lib.Logger.Debug(cli_args, "sourcedir", *sourcedir)
		lib.Logger.Debug(cli_args, "targetdir", *targetdir)
	}

	// flag assertions
	{
		lib.Assert((*onlyInstall && *onlyUninstall) == false, "cannot pass both --only-install and --only-uninstall")
		lib.Assert((*install && *onlyUninstall) == false, "cannot pass both --install and --only-uninstall")
		lib.Assert((*onlyInstall && *uninstall) == false, "cannot pass both --only-install and --uninstall")
		lib.Assert((*install && *upgrade) == false, "cannot pass both --install and --upgrade flags")
		lib.Assert((*onlyInstall && *upgrade) == false, "cannot pass both --only-install and --upgrade flags")
		lib.Assert((*uninstall && *upgrade) == false, "cannot pass both --uninstall and --upgrade flags")
		lib.Assert((*onlyUninstall && *upgrade) == false, "cannot pass both --only-uninstall and --upgrade flags")
	}

	dirPath := *sourcedir + "/config"
	entries, err := os.ReadDir(dirPath)
	if err != nil {
		lib.Logger.Error("couldn't read dir", "err", err)
		return
	}

	lockfilePath := *targetdir + "/hmlock.json"
	lockfileDiffPath := *targetdir + "/hmlock_diff.json"
	lockfile, err := lib.ReadOrCreateLockfile(lockfilePath)
	if err != nil {
		lib.Logger.Error("something went wrong while parsing the lockfile, you might need to remove it manually (possibly was generated by previous version of `hm`", "err", err)
		return
	}
	lockfileBefore := *lockfile
	defer func() {
		err := lockfile.Save(lockfilePath, defaultIndent)
		if err != nil {
			lib.Logger.Error("something went wrong while trying to save the lockfile", "err", err)
			return
		}
	}()

	// TODO: think if this is correct, for now just reset
	*lockfile = lib.DefaultLockfile

	if *copyMode {
		lib.Logger.Debug("setting mode to cpy")
		lockfile.Mode = lib.Cpy
	} else {
		lib.Logger.Debug("setting mode to dev")
		lockfile.Mode = lib.Dev
	}

	for _, e := range entries {
		if e.Type() != os.ModeDir {
			continue
		}

		name := e.Name()
		if name == ".git" {
			continue
		}

		from := dirPath + "/" + name
		to := *targetdir + "/" + name

		if name[0] == '.' {
			lib.Logger.Info("configs", "skipping", name)
			// skipping the dot
			nameIfNotSkipped := name[1:]
			fromIfNotSkipped := dirPath + "/" + nameIfNotSkipped
			toIfNotSkipped := *targetdir + "/" + nameIfNotSkipped
			config := lib.NewConfig(nameIfNotSkipped, fromIfNotSkipped, toIfNotSkipped, nil)
			lockfile.AppendSkippedConfig(config)
			continue
		}

		requirements, err := lib.ParseRequirements(from)
		if err != nil {
			lib.Logger.Error("something went wrong while trying to parse requirements", "err", err)
			return
		}

		config := lib.NewConfig(name, from, to, requirements)
		lockfile.AddConfig(config)
	}

	pkgs := []string{}
	if *pkgsTxt != "" {
		pkgs = strings.Split(*pkgsTxt, ",")
	}

	if !*onlyUninstall && !*onlyInstall {
		for _, cfg := range lockfile.Configs {
			if *copyMode {
				lib.Logger.Info("copying", "from", cfg.From, "to", cfg.To)
				err := lib.Copy(cfg.From, cfg.To)
				if err != nil {
					lib.Logger.Error("couldn't copy", "err", err)
					return
				}
			} else {
				lib.Logger.Info("symlinking", "from", cfg.From, "to", cfg.To)
				err := lib.Symlink(cfg.From, cfg.To)
				if err != nil {
					lib.Logger.Error("couldn't symlink", "err", err)
					return
				}
			}
		}
	} else {
		lib.Logger.Info("skipping copying/symlinking the config, because --only-install or --only-uninstall was passed")
	}

	// previously installed/uninstalled pkgs pointing to idx in the lockfileBefore, so that the information can be copied
	previouslyInstalled := make(map[string]int)
	for idx, cfg := range lockfileBefore.Configs {
		if cfg.InstallInfo.IsInstalled || cfg.InstallInfo.WasUninstalled {
			previouslyInstalled[cfg.Name] = idx
		}
	}

	// copy that installation info from the previous lock regardless of installation/upgrade/uninstallation
	for idx, cfg := range lockfile.Configs {
		if idxInBefore, ok := previouslyInstalled[cfg.Name]; ok {
			prevInstInfo := &lockfileBefore.Configs[idxInBefore].InstallInfo
			lockfile.Configs[idx].InstallInfo = *prevInstInfo
		}
	}

	if *install || *onlyInstall || *upgrade {
		for idx, cfg := range lockfile.Configs {
			if _, ok := previouslyInstalled[cfg.Name]; ok {
				instInfo := &cfg.InstallInfo
				if instInfo.IsInstalled && *upgrade {
					lib.Logger.Info("upgrading an already installed pkg", "name", cfg.Name)
				} else if instInfo.IsInstalled {
					lib.Logger.Debug("skipping config for installation, because it is already installed, to upgrade pass the --upgrade flag", "name", cfg.Name)
					continue
				} else if instInfo.WasUninstalled {
					lib.Logger.Debug("installing a previously uninstalled pkg", "name", cfg.Name)
				} else {
					panic("shouldnt be possible to get here if its neither installed nor uninstalled")
				}
			}

			if len(pkgs) > 0 && !slices.Contains(pkgs, cfg.Name) {
				lib.Logger.Debug("skipping config for installation, because it wasnt in the provided list", "skipped", cfg.Name)
				continue
			}

			info, err := lib.Install(cfg)
			if err != nil {
				lib.Logger.Error("something went wrong while trying to install using the INSTALL instructions", "pkg", cfg.Name, "err", err)
				continue
			}
			lockfile.Configs[idx].InstallInfo = *info
		}
	}

	if *uninstall || *onlyUninstall {
		for idx, cfg := range lockfile.SkippedConfigs {
			if len(pkgs) > 0 && !slices.Contains(pkgs, cfg.Name) {
				lib.Logger.Debug("skipping config for uninstallation, because it wasnt in the provided list", "skipped", cfg.Name)
				continue
			}

			info, err := lib.Uninstall(cfg)
			if err != nil {
				lib.Logger.Error("something went wrong while trying to uninstall using the instructions", "pkg", cfg.Name, "err", err)
				continue
			}
			lockfile.Configs[idx].InstallInfo = *info
		}
	}

	lockDiff := lockfileBefore.Diff(lockfile)
	{
		err := lockDiff.Save(lockfileDiffPath, defaultIndent)
		if err != nil {
			lib.Logger.Error("something went wrong while trying to save lockfile diff to a file", "err", err)
			return
		}
		lib.Logger.Info("saved lockfile diff to a file", "path", lockfileDiffPath)

		lib.Logger.Info("removing configs that are no longer in the source")
		err = lib.RemoveConfigsFromTarget(lockDiff.RemovedConfigs)
		if err != nil {
			lib.Logger.Error("something went wrong while removing a config", "mode", lockfile.Mode)
			return
		}

		lib.Logger.Info("removing configs that are skipped")
		err = lib.RemoveConfigsFromTarget(lockDiff.NewlySkippedConfigs)
		if err != nil {
			lib.Logger.Error("something went wrong while removing a config", "mode", lockfile.Mode)
			return
		}
	}

}
